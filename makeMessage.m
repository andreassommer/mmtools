function varargout = makeMessage(arg1_printer, arg2_fID, varargin)
% makeMessage( ... )
% makeMessage( fID, ... )
% makeMessage( printfunc, ... )
% makeMessage( printfunc, fID, ... )
% out = makeMessage( ... )
%
% Displays informative messages.
%
% makeMessage is a wrapper to fprintf (or other printers), preponing the output with the name of the caller
%
% INPUT:    printfunc --> if specified, the printer function to be called  [optional, default: fprintf]
%                 fID --> if specified, file ID to be printed to (passed to printer as 1st argument)
%                 ... --> argument list passed to the printer function
%
% OUTPUT:   out --> output generated by the printer function (only first output argument is returned)
%
%
% Andreas Sommer, Aug2023
% code@andreas-sommer.eu
%


% defaults
default_printer  = @fprintf;
default_fID      = [];
caller_formatter = @caller_formatter_centered;
format_processor = @format_processor_default;
output_requested = (nargout > 0);

% get caller first (because makeMessage might call other functions)
caller = getCaller(1);  % 1: depth excluding makeMessage itself

% 5 cases of calling:
% (1) makeMessage()
% (2) makeMessage(...)
% (3) makeMessage(fID, ...)
% (4) makeMessage(printer, ...)
% (5) makeMessage(printer, fID, ...)

% CASE (1):  makeMessage()
if (nargin == 0)
   printerargs = {};
   varargout = callPrinter(caller, defaultprinter, default_fID, printerargs); 
   return; 
end

% Determine type of arg1 and arg2
if (nargin >= 1)
   arg1_is_printer = isa(arg1_printer, 'function_handle');
   arg1_is_fID     = isnumeric(arg1_printer);
end
if (nargin >= 2)
   arg2_is_fID  = arg1_is_printer && isnumeric(arg2_fID);
else
   arg2_is_fID  = false;
end


% CASE (2):  makeMessage(...)
if ~(arg1_is_printer || arg1_is_fID) && ~arg2_is_fID
   if (nargin == 1)
      printerargs = { arg1_printer };                          % just single print arc
   else
      printerargs = [ {arg1_printer , arg2_fID}  varargin];    % all are print args
   end
   varargout = callPrinter(caller, default_printer, default_fID, printerargs);
   return
end
% CASE (3):  makeMessage(fID, ...)
if arg1_is_fID 
   fID = arg1_printer;
   if (nargin == 1)
      printerargs = {};
   else
      printerargs = [ {arg2_fID} , varargin ];
   end
   varargout = callPrinter(caller, default_printer, fID, printerargs);
   return
end
% CASE (4):  makeMessage(printer, ...)
if arg1_is_printer && (~arg2_is_fID)
   if (nargin == 1)
      printerargs = {};
   else
      printerargs = [ {arg2_fID} , varargin ];
   end
   varargout = callPrinter(caller, arg1_printer, default_fID, printerargs);
   return
end

% if we reached this point, we are in case (5)

% CASE (5): makeMessage(printer, fID, ...)
printerargs = varargin;
varargout = callPrinter(caller, arg1_printer, arg2_fID, printerargs);



% finito

%% internal helper
   function out = callPrinter(caller, printer, fID, printerargs)
      out = makeMessageInternal(caller, caller_formatter, format_processor, output_requested, printer, fID, printerargs);
   end

end % of function


%% HELPERS

function out = makeMessageInternal(caller, caller_formatter, format_processor, output_requested, printer, fID, args)
   % INTERNAL PRINTER  

   % build the format string
   if isempty(args)
      fmt = '';
      args = {};
   elseif ( length(args)==1 )
      fmt = args{1};
      args = {};
   else
      fmt = args{1};
      args = args{2:end};
   end


   % add caller to format string
   caller = caller_formatter(caller);
   
   % make/process format string
   fmt = format_processor(fmt, caller);

   % build the argument list
   if isempty(fID)
      printerargs = [ {fmt} , args];
   else
      printerargs = [ { fID , fmt }, args];
   end

   % corner case everything empty: ensure it's a cell
   if ~iscell(printerargs), printerargs = {}; end

   % invoke the printer - works also if args is (empty) 1x0 cell array
   try
      if (output_requested)
         out = printer(printerargs{:});
         out = {out}; % out becomes varargout
      else
         printer(printerargs{:});
         out = {};    % out becomes varargout
      end
   catch ME
      warning('Printer error.  --  Printer = @%s  --  fID = %g ', func2str(printer), fID)
      rethrow(ME)
   end

end

%% HELPERS

function caller = caller_formatter_default(caller)
   fieldWidth = 25;
   fmt = '[%*s]';
   caller = upper(caller);
   caller = sprintf(fmt, fieldWidth, caller);
end


function caller = caller_formatter_centered(caller)
   fieldWidth = 25;
   caller = upper(caller);
   caller = sprintf('[%s]', centerStr(caller, fieldWidth));
end


function str = centerStr(str, fieldwidth)
   strlen = length(str);
   if strlen > fieldwidth; return; end  % dont touch string if too long
   mid = (fieldwidth - strlen) / 2;
   str = sprintf('%*s%*s', fix(mid)+numel(str), str, ceil(mid), '');
end




function fmt = format_processor_default(fmt, caller)
   fmt = convertStringsToChars(fmt);   % ensure char arrays
   [fmt, newlines] = processBeginningNewlines(fmt);           % emit newlines first, before [caller]
   fmt = sprintf('%s%s  %s', newlines, caller, fmt);
end

function [fmt, newlines] = processBeginningNewlines(fmt)
   newlinecode = '\n';
   newlinecount = 0;
   newlines = '';
   while startsWith(fmt,newlinecode)
      newlinecount = newlinecount + 1;
      fmt(1:2) = [];  % remove '\n' from format
      newlines(end+1) = newline(); %#ok<AGROW>   Probably only 1,2,3 times a newline
   end
end